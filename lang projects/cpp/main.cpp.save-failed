#include <nullscript/nullscript.h>
#include <nullscript/rules.h>
#include <module.h>

using namespace NULLSCR;

enum Ids
{
    None = 0,
    Semicolon,
    Colon,
    Period,
    DoubleColon,
    Keyword,
    Keyword_Namespace,
    Keyword_Class,
    Keyword_Struct,
    Keyword_Template,
    Separator,
    Operator,
    Modifier,
    CurlyScope,
    RoundScope,
    SquareScope,
    PointyScope,
    String,
    Char,
    Comment,
    Number,
    Cas,
    Vla,
    Template,

    Namespace,
    Class,
    Type,
    Variable,
    Function,
    Alias
};

enum ScopeTypes
{
    Curly = 0,
    Round,
    Square,
    Pointy
};

enum VLA
{
    Private,
    Protected,
    Public
};

char const* VlaToStr(VLA c)
{
    switch (c)
    {
    case Private:
        return "private";
    case Protected:
        return "protected";
    case Public:
        return "public";
    }
    return "";
}

class EmptyToken: public TokenBase<EmptyToken>
{
    virtual char const* getName() const noexcept override
    {
        return "empty";
    }

    using TokenBase::TokenBase;
};

class NamespaceToken: public ScopeToken
{
public:
    virtual char const* getName() const noexcept override
    {
        return "namespace";
    }
    virtual std::type_index getType() const noexcept override
    {
        return typeid(NamespaceToken);
    }
    std::string name;
    NamespaceToken(const std::string& n): ScopeToken(0),name(n) { setPos(0); };
    NamespaceToken(const NamespaceToken& t): ScopeToken(t) {};
    NamespaceToken(NamespaceToken&&) noexcept = default;
};

class ClassToken: public ScopeToken
{
public:
    std::string name,templateP;
    VLA level;
    std::vector<std::tuple<VLA,std::string,std::string>> parents;

    virtual char const* getName() const noexcept override
    {
        return "class";
    }
    virtual std::type_index getType() const noexcept override
    {
        return typeid(ClassToken);
    }

    ClassToken(const std::string& n): ScopeToken(0),name(n) { setPos(0); };
    ClassToken(const ClassToken& t): ScopeToken(t) {};
    ClassToken(ClassToken&&) noexcept = default;
};

class AliasToken: public ScopeToken
{
public:
    virtual char const* getName() const noexcept override
    {
        return "alias";
    }
    virtual std::type_index getType() const noexcept override
    {
        return typeid(AliasToken);
    }
    std::string name;
    AliasToken(const std::string& n): ScopeToken(0),name(n) { setPos(0); };
    AliasToken(const AliasToken& t): ScopeToken(t) {};
    AliasToken(AliasToken&&) noexcept = default;
};

class VariableToken: public TokenBase<VariableToken>
{
public:
    virtual char const* getName() const noexcept override
    {
        return "variable";
    }

    std::string name;
    ARCDOC::TypeInfo type;

    VariableToken(const std::string& n): name(n) { setPos(0); };
    VariableToken(const VariableToken&) = default;
    VariableToken(VariableToken &&) noexcept = default;
};

class FunctionToken: public TokenBase<FunctionToken>
{
public:
    virtual char const* getName() const noexcept override
    {
        return "function";
    }

    std::string name;
    std::vector<std::string> modifiers;
    ARCDOC::TypeInfo type;
    std::vector<std::pair<ARCDOC::TypeInfo,std::string>> args;

    FunctionToken(const std::string& n): name(n) { setPos(0); };
    FunctionToken(const FunctionToken&) = default;
    FunctionToken(FunctionToken &&) noexcept = default;
};

class CasToken: public TokenBase<FunctionToken>
{
public:
    virtual char const* getName() const noexcept override
    {
        return "cas";
    }

    VLA level;

    CasToken(VLA c): level(c) { setPos(0); };
    CasToken(const CasToken&) = default;
    CasToken(CasToken &&) noexcept = default;
};

std::string stringifyTokens(const std::vector<TokenEntity>& s)
{
    const char scopes[4][2] = {
        {'{','}'},
        {'(',')'},
        {'[',']'},
        {'<','>'}
    };
    std::string ret;
    for (const auto& i:s)
    {
        if (i.token -> getType() == typeid(ScopeToken))
        {
            ScopeToken& st = i.token -> forceAs<ScopeToken>();
            ret += scopes[st.type][0];
            ret += stringifyTokens(st.tokens);
            ret += scopes[st.type][1];
        }
        else if (i.type == Ids::Semicolon)
        {
            ret += ";";
        }
        else if (i.type == Ids::Colon)
        {
            ret += ":";
        }
        else if (i.type == Ids::Comment)
        {
            StringToken* st = i.token -> as<StringToken>();
            if (st != nullptr)
            {
                if (ret.size())
                    ret += ' ';
                ret += st -> str;
            }
        }
    }
    return ret;
}

std::unique_ptr<Token> creator(const std::string& source,unsigned id)
{
    switch (id)
    {
    case Ids::CurlyScope:
    case Ids::RoundScope:
    case Ids::SquareScope:
    case Ids::PointyScope:
        {
            return std::unique_ptr<Token>(new ScopeToken(0));
            break;
        }
    case Ids::Semicolon:
    case Ids::Colon:
    case Ids::Keyword_Template:
    case Ids::DoubleColon:
    case Ids::Period:
        {
            return std::unique_ptr<Token>(new EmptyToken());
            break;
        }
    case Ids::Comment:
        {
            if (source.size() >= 2)
            {
                if (source[1] == '*')
                {
                    return std::unique_ptr<Token>(new StringToken(0,source.substr(2,source.size()-4)));
                }
                return std::unique_ptr<Token>(new StringToken(0,source.substr(2,source.size()-3)));
            }
            break;
        }
    case Ids::Vla:
        {
            VLA c = VLA::Public;
            if (source == "protected")
                c = VLA::Protected;
            else if (source == "private")
                c = VLA::Private;
            return std::unique_ptr<Token>(new CasToken(c));
        }
    }
    return std::unique_ptr<Token>(new StringToken(0,source));
}

void templateBracketsInCurlyFunc(std::vector<TokenEntity>& tokens)
{
    std::vector<unsigned> scopes;
    int offset = 0;

    while (static_cast<unsigned>(offset) < tokens.size())
    {
        if (tokens[offset].type == Ids::Operator)
        {
            std::string op = tokens[offset].token->forceAs<StringToken>().str;
            if (op == "<")
            {
                scopes.push_back(offset);
            }
            else if (op == ">")
            {
                if (scopes.size())
                {
                    auto beg = tokens.begin()+scopes.back();
                    auto en = tokens.begin()+offset;
                    ScopeToken *sc = new ScopeToken(beg->token->getPos());

                    sc->tokens.resize(en - beg - 1);
                    std::move(beg+1,en,sc->tokens.begin());
                    //sc->tokens.insert(sc->tokens.begin(),beg+1,en);
                    offset -= (en - beg);
                    tokens.erase(beg,en+1);
                    tokens.emplace(tokens.begin()+scopes.back(),std::unique_ptr<Token>(sc),Ids::PointyScope);
                    scopes.pop_back();
                }
                else
                {
                    //error
                }
            }
            else if (op == ">>")
            {
                if (scopes.size() > 1)
                {
                    unsigned b = scopes.back();
                    auto beg = tokens.begin()+b;
                    auto en = tokens.begin()+offset;
                    ScopeToken *sc = new ScopeToken(beg->token->getPos());

                    sc->tokens.resize(en - beg - 1);
                    std::move(beg+1,en,sc->tokens.begin());
                    //sc->tokens.insert(sc->tokens.begin(),beg+1,en);
                    offset -= (en - beg) + 1;
                    tokens.erase(beg,en+1);

                    scopes.pop_back();

                    beg = tokens.begin() + scopes.back();
                    en = tokens.begin() + b - 1;

                    ScopeToken *sc2 = new ScopeToken(beg->token->getPos());

                    sc2->tokens.resize(en - beg - 1);
                    std::move(beg+1,en,sc2->tokens.begin());
                    //sc2->tokens.insert(sc2->tokens.begin(),beg+1,en);

                    sc2->tokens.emplace_back(std::unique_ptr<Token>(sc),Ids::PointyScope);
                    offset -= (en - beg) - 1;
                    tokens.erase(beg,en);
                    tokens.emplace(tokens.begin()+scopes.back(),std::unique_ptr<Token>(sc2),Ids::PointyScope);
                    scopes.pop_back();
                }
                else
                {
                    //error
                }
            }
        }
        ++offset;
    }
}

void templateBracketsFunc(std::vector<TokenEntity>& tokens)
{
    std::vector<unsigned> scopes;

    int offset = 0;
    while (static_cast<unsigned>(offset) < tokens.size())
    {
        if (tokens[offset].type == Ids::RoundScope)
        {
            if (scopes.size())
            {
                //error
            }
            templateBracketsInCurlyFunc(tokens[offset].token->forceAs<ScopeToken>().tokens);

            ++offset;
            while (static_cast<unsigned>(offset) < tokens.size() && tokens[offset].type == Ids::Modifier) ++offset;
        }
        else if (tokens[offset].type == Ids::CurlyScope)
        {
            if (scopes.size())
            {
                //error
            }
            templateBracketsFunc(tokens[offset].token->forceAs<ScopeToken>().tokens);
        }
        else
        {
            if (tokens[offset].type == Ids::Operator)
            {
                std::string op = tokens[offset].token->forceAs<StringToken>().str;
                if (op == "<")
                {
                    scopes.push_back(offset);
                }
                else if (op == ">")
                {
                    if (scopes.size())
                    {
                        auto beg = tokens.begin()+scopes.back();
                        auto en = tokens.begin()+offset;
                        ScopeToken *sc = new ScopeToken(beg->token->getPos());

                        sc->tokens.resize((en - beg) - 1);
                        std::move(beg+1,en,sc->tokens.begin());
                        //sc->tokens.insert(sc->tokens.begin(),beg+1,en);

                        offset -= (en - beg);
                        tokens.erase(beg,en+1);
                        tokens.emplace(tokens.begin()+scopes.back(),std::unique_ptr<Token>(sc),Ids::PointyScope);
                        scopes.pop_back();
                    }
                    else
                    {
                        //error
                    }
                }
                else if (op == ">>")
                {
                    if (scopes.size() > 1)
                    {
                        unsigned b = scopes.back();
                        auto beg = tokens.begin()+b;
                        auto en = tokens.begin()+offset;
                        ScopeToken *sc = new ScopeToken(beg->token->getPos());

                        sc->tokens.resize(en - beg - 1);
                        std::move(beg+1,en,sc->tokens.begin());
                        //sc->tokens.insert(sc->tokens.begin(),beg+1,en);
                        offset -= (en - beg) +1;
                        tokens.erase(beg,en+1);

                        scopes.pop_back();

                        beg = tokens.begin() + scopes.back();
                        en = tokens.begin() + b - 1;

                        ScopeToken *sc2 = new ScopeToken(beg->token->getPos());

                        sc2->tokens.resize(en - beg - 1);
                        std::move(beg+1,en,sc2->tokens.begin());
                        //sc2->tokens.insert(sc2->tokens.begin(),beg+1,en);

                        sc2->tokens.emplace_back(std::unique_ptr<Token>(sc),Ids::PointyScope);

                        offset -= (en - beg) - 1;
                        tokens.erase(beg,en);
                        tokens.emplace(tokens.begin()+scopes.back(),std::unique_ptr<Token>(sc2),Ids::PointyScope);
                        scopes.pop_back();
                    }
                    else
                    {
                        //error
                    }
                }
            }
        }
        ++offset;
    }
}

void setupSlt(Stage* slt)
{
    LexicalRule* lrs = new LexicalRule();

    lrs -> addParsePoint(std::regex("\\s"),Ids::Separator,LexicalRule::States::forget,false);

    lrs -> addParsePoint(";",Ids::Semicolon,LexicalRule::Modes::String,LexicalRule::States::insert,false);

    lrs -> addParsePoint(":",Ids::Colon,LexicalRule::Modes::String,LexicalRule::States::insert,false);

    const char* keywords[] = {
        "alignas",
        "alignof",
        "auto",
        "concept",
        "const",
        "consteval",
        "constexpr",
        "decltype",
        "default",
        "delete",
        "enum",
        "explicit",
        "extern",
        "friend",
        "inline",
        "mutable",
        "noexcept",
        "operator",
        "register",
        "requires",
        "short",
        "signed",
        "static",
        "throw",
        "typedef",
        "typename",
        "union",
        "using",
        "unsigned",
        "void",
        "volatile"
    };

    const char* wrd_operators[] = {
        "and",
        "and_eq",
        "bitand",
        "bitor",
        "comlp",
        "not",
        "not_eq",
        "or",
        "or_eq",
        "xor",
        "xor_eq"
    };

    const char* operators[] = {
        "&&",
        "&=",
        "&",
        "|",
        "~",
        "!",
        "!=",
        "||",
        "|=",
        "^",
        "^=",
        ".",
        "->",
        "?",
        "%",
        "+",
        "+=",
        "-",
        "-=",
        "/",
        "/=",
        "*",
        "*=",
        "=",
        "==",
        "<",
        "<=",
        ">",
        ">="
    };

    for (auto i: keywords)
        lrs -> addParsePoint(i,Ids::Keyword,LexicalRule::Modes::Keyword,LexicalRule::States::insert,false);
    lrs -> addParsePoint("namespace",Ids::Keyword_Namespace,LexicalRule::Modes::Keyword,LexicalRule::States::insert,false);
    lrs -> addParsePoint("template",Ids::Keyword_Template,LexicalRule::Modes::Keyword,LexicalRule::States::insert,false);

    lrs -> addParsePoint("class",Ids::Keyword_Class,LexicalRule::Modes::Keyword,LexicalRule::States::insert,false);
    lrs -> addParsePoint("struct",Ids::Keyword_Struct,LexicalRule::Modes::Keyword,LexicalRule::States::insert,false);


    lrs -> addParsePoint("private",Ids::Vla,LexicalRule::Modes::Keyword,LexicalRule::States::insert,false);
    lrs -> addParsePoint("protected",Ids::Vla,LexicalRule::Modes::Keyword,LexicalRule::States::insert,false);
    lrs -> addParsePoint("public",Ids::Vla,LexicalRule::Modes::Keyword,LexicalRule::States::insert,false);

    for (auto i: wrd_operators)
        lrs -> addParsePoint(i,Ids::Operator,LexicalRule::Modes::Keyword,LexicalRule::States::insert,false);
    for (auto i: operators)
        lrs -> addParsePoint(i,Ids::Operator,LexicalRule::Modes::String,LexicalRule::States::insert,false);

    lrs -> addParsePoint("::",Ids::DoubleColon,LexicalRule::Modes::String,LexicalRule::States::insert,false);
    lrs -> addParsePoint(",",Ids::Period,LexicalRule::Modes::String,LexicalRule::States::insert,false);

    //scopes
    lrs -> addParsePoint("{",Ids::CurlyScope,LexicalRule::Modes::String,LexicalRule::States::push,true);
    lrs -> addParsePoint("}",Ids::CurlyScope,LexicalRule::Modes::String,LexicalRule::States::pop);

    lrs -> addParsePoint("[",Ids::SquareScope,LexicalRule::Modes::String,LexicalRule::States::push,true);
    lrs -> addParsePoint("]",Ids::SquareScope,LexicalRule::Modes::String,LexicalRule::States::pop);

    lrs -> addParsePoint("(",Ids::RoundScope,LexicalRule::Modes::String,LexicalRule::States::push,true);
    lrs -> addParsePoint(")",Ids::RoundScope,LexicalRule::Modes::String,LexicalRule::States::pop);

    lrs -> addParsePoint(std::regex("\\d+(?:\\.\\d*(?:(f)|(d)|(u?[l]{0,2}))?)?"),Ids::Number,LexicalRule::States::insert,false);
    lrs -> addParsePoint(std::regex("\\w\\d+(?:\\.\\d*(?:(f)|(d)|(u?[l]{0,2}))?)?"),Ids::Number,LexicalRule::States::ignore,false);
    lrs -> addParsePoint(std::regex("\\.\\d*(?:(f)|(d)|(u?[l]{0,2}))?"),Ids::Number,LexicalRule::States::insert,false);

    lrs -> addParsePoint("\'",Ids::Char,LexicalRule::Modes::String,LexicalRule::States::toggle);
    lrs -> addParsePoint("\"",Ids::String,LexicalRule::Modes::String,LexicalRule::States::toggle);

    //comments
    lrs -> addParsePoint("//",Ids::Comment,LexicalRule::Modes::String,LexicalRule::States::insert,false);
    lrs -> addParsePoint("\\\n",Ids::Comment,LexicalRule::Modes::String,LexicalRule::States::forget,false);
    lrs -> addParsePoint("/*",Ids::Comment,LexicalRule::Modes::String,LexicalRule::States::push,false);
    lrs -> addParsePoint("*/",Ids::Comment,LexicalRule::Modes::String,LexicalRule::States::pop,false);

    lrs -> setTokenCreator(creator);

    slt -> rules.emplace_back(lrs);

    ComplexRule* bmf = new ComplexRule(templateBracketsFunc);
    bmf -> deep = false;

    slt -> rules.emplace_back(bmf);
}

void preprocessorFunc(std::vector<TokenEntity>& source)
{
    //
}

void setupPrp(Stage* prp)
{
    ComplexRule* pr = new ComplexRule(preprocessorFunc,true);
    prp -> rules.emplace_back(pr);
}

std::unique_ptr<Token> preMergerFunc(unsigned b,unsigned e,unsigned t,const std::vector<TokenEntity>& source)
{
    switch (t)
    {
    case Ids::Template:
        {
            ScopeToken* tm = new ScopeToken(0);
            tm->tokens = std::move(source[b+1].token->forceAs<ScopeToken>().tokens);
            return std::unique_ptr<Token>(tm);
        }
    }
    return std::unique_ptr<Token>();
}

std::unique_ptr<Token> mergerFunc(unsigned b,unsigned e,unsigned t,const std::vector<TokenEntity>& source)
{
    switch (t)
    {
    case Ids::Namespace:
        {
            NamespaceToken* ns = new NamespaceToken(source[b+1].token->forceAs<StringToken>().str);
            ns -> tokens = std::move(source[b+2].token->forceAs<ScopeToken>().tokens);
            return std::unique_ptr<Token>(ns);
            break;
        }
    case Ids::Class:
        {
            unsigned nameOffset = b+1;
            while (nameOffset+1 < e && source[nameOffset].type != 0) ++nameOffset;

            ClassToken* cls = new ClassToken(source[nameOffset].token->forceAs<StringToken>().str);

            unsigned i=nameOffset+1;

            while (i<e && source[i].type != Ids::CurlyScope) ++i;

            if (i != e)
            {
                cls -> tokens = std::move(source[i].token->forceAs<ScopeToken>().tokens);
            }
            return std::unique_ptr<Token>(cls);
            break;
        }
    }
    return std::unique_ptr<Token>();
}

void setupMrg(Stage* mrg)
{
    LayeredMergingRule* preLmr = new LayeredMergingRule();

    preLmr -> deep = true;
    preLmr -> setTokenMerger(preMergerFunc);
    preLmr -> layers.emplace_back();

    preLmr -> layers[0].addTypePath({Ids::Keyword_Template,Ids::PointyScope},Ids::Template);

    LayeredMergingRule* lmr = new LayeredMergingRule();
    lmr -> deep = true;
    lmr -> setTokenMerger(mergerFunc);
    lmr -> layers.emplace_back();

    MergingLayer& lr1 = lmr -> layers[0];

    lr1.addTypePath({Ids::Keyword_Namespace,Ids::None,Ids::CurlyScope},Ids::Namespace);

    MergingLayer::TypesTrieNode* classEntry = lr1.addTypePath({Ids::Keyword_Class},-1);

    lr1.connectTypePath({Ids::Keyword_Struct},classEntry);
    lr1.connectTypePath({Ids::Template,Ids::Keyword_Class},classEntry);
    lr1.connectTypePath({Ids::Template,Ids::Keyword_Struct},classEntry);

    classEntry = lr1.appendTypePath(classEntry,{Ids::None},-1);

    MergingLayer::TypesTrieNode* classExit = lr1.appendTypePath(classEntry,{Ids::Semicolon},Ids::Class);
    MergingLayer::TypesTrieNode* classBeforeExit = lr1.appendTypePath(classEntry,{Ids::CurlyScope},-1);

    lr1.connectTypePath(classBeforeExit,{Ids::Semicolon},classExit);

    MergingLayer::TypesTrieNode* classParentsEntry = lr1.appendTypePath(classEntry,{Ids::Colon},-1);
    MergingLayer::TypesTrieNode* classParentsExit = lr1.appendTypePath(classParentsEntry,{Ids::Vla,Ids::None},-1);

    lr1.connectTypePath(classParentsEntry,{Ids::Vla,Ids::DoubleColon,Ids::None},classParentsExit);

    lr1.connectTypePath(classParentsExit,{Ids::Period},classParentsEntry);
    lr1.connectTypePath(classParentsExit,{Ids::CurlyScope},classBeforeExit);

    MergingLayer::TypesTrieNode* classParentsNamespace = lr1.appendTypePath(classParentsExit,{Ids::DoubleColon},-1);

    lr1.connectTypePath(classParentsNamespace,{Ids::None},classParentsExit);
    lr1.connectTypePath(classParentsExit,{Ids::PointyScope,Ids::DoubleColon},classParentsNamespace);
    lr1.connectTypePath(classParentsExit,{Ids::PointyScope,Ids::CurlyScope},classBeforeExit);

    mrg -> rules.emplace_back(preLmr);
    mrg -> rules.emplace_back(lmr);
}

ARCDOC::Namespace* createNamespaceFt(NamespaceToken& nt)
{
    ARCDOC::Namespace* n = new ARCDOC::Namespace(nt.name);
    return n;
}

ARCDOC::Structure* createStructureFt(ClassToken& ct)
{
    ARCDOC::Structure* n = new ARCDOC::Structure(ct.name);
    for (const auto& parent: ct.parents)
    {
        n -> parents.emplace_back(std::string(VlaToStr(std::get<0>(parent)))+" "+std::get<1>(parent),std::get<2>(parent));
    }
    return n;
}

ARCDOC::Function* createFunctionFt(FunctionToken& ft)//
{
    ARCDOC::Function* n = new ARCDOC::Function(ft.name);
    n -> type = ft.type;
    n -> modifiers = ft.modifiers;
    n -> args = ft.args;
    return n;
}

ARCDOC::Variable* createVariableFt(VariableToken& vt)//
{
    ARCDOC::Variable* n = new ARCDOC::Variable(vt.name);
    n -> type = vt.type;
    return n;
}

ARCDOC::Alias* createAliasFt(AliasToken& at)
{
    ARCDOC::Alias* n = new ARCDOC::Alias(at.name);
    n -> target = stringifyTokens(at.tokens);
    return n;
}

void recursiveClassExtract(const std::vector<TokenEntity>& source, ARCDOC::Structure& target,VLA def)
{
    VLA level = def;
    for (const auto& i:source)
    {
        if (i.type == Ids::Class)
        {
            ClassToken& ct = i.token -> forceAs<ClassToken>();
            ARCDOC::Structure* n = createStructureFt(ct);
            target.members[VlaToStr(level)].emplace_back(n);
            recursiveClassExtract(ct.tokens,*n,ct.level);
        }
        else if (i.type == Ids::Function)
        {
            FunctionToken& ft = i.token -> forceAs<FunctionToken>();
            ARCDOC::Function* n = createFunctionFt(ft);
            target.members[VlaToStr(level)].emplace_back(n);
        }
        else if (i.type == Ids::Variable)
        {
            VariableToken& vt = i.token -> forceAs<VariableToken>();
            ARCDOC::Variable* n = createVariableFt(vt);
            target.members[VlaToStr(level)].emplace_back(n);
        }
        else if (i.type == Ids::Alias)
        {
            AliasToken& at = i.token -> forceAs<AliasToken>();
            ARCDOC::Alias* n = createAliasFt(at);
            target.members[VlaToStr(level)].emplace_back(n);
        }
        else if (i.type == Ids::Cas)
        {
            level = i.token -> forceAs<CasToken>().level;
        }
    }
}

void recursiveNamespaceSearch(const std::vector<TokenEntity>& source, ARCDOC::Namespace& target)
{
    for (const auto& i:source)
    {
        if (i.type == Ids::Namespace)
        {
            NamespaceToken& nt = i.token -> forceAs<NamespaceToken>();
            ARCDOC::Namespace* n = createNamespaceFt(nt);
            target.members.emplace_back(n);
            recursiveNamespaceSearch(nt.tokens,*n);
        }
        else if (i.type == Ids::Class)
        {
            ClassToken& ct = i.token -> forceAs<ClassToken>();
            ARCDOC::Structure* n = createStructureFt(ct);
            target.members.emplace_back(n);
            recursiveClassExtract(ct.tokens,*n,ct.level);
        }
        else if (i.type == Ids::Function)
        {
            FunctionToken& ft = i.token -> forceAs<FunctionToken>();
            ARCDOC::Function* n = createFunctionFt(ft);
            target.members.emplace_back(n);
        }
        else if (i.type == Ids::Alias)
        {
            AliasToken& at = i.token -> forceAs<AliasToken>();
            ARCDOC::Alias* n = createAliasFt(at);
            target.members.emplace_back(n);
        }
    }
}

void tokenizerSetup(Tokenizer& tk)
{
    tk.addStage("splitting");
    tk.addStage("preprocessing");
    tk.addStage("merging");

    Stage* slt_stage = tk.findStage("splitting");
    Stage* prp_stage = tk.findStage("preprocessing");
    Stage* mrg_stage = tk.findStage("merging");

    setupSlt(slt_stage);
    setupPrp(prp_stage);
    setupMrg(mrg_stage);
}


void extractor(const std::vector<TokenEntity>& source, ARCDOC::Namespace& target)
{
    //NULLSCR::printTokens(source,std::cerr,true);
    recursiveNamespaceSearch(source,target);
}

class CppModule: public ARCDOC::Module
{
private:
    void recursiveTreeExport(const ARCDOC::Member& m,ParseLib::XML::Tag* ret)
    {
        if (m.getType() == typeid(ARCDOC::Namespace))
        {
            ParseLib::XML::Tag* tmp = new ParseLib::XML::Tag();
            ret->children.emplace_back(tmp);

            if (m.name.size())
                ret->children.emplace_back(std::move(ParseLib::XML::parse("<name>"+m.name+"</name>")->children[0]));

            tmp->name="list";

            for(const auto& i: reinterpret_cast<const ARCDOC::Namespace&>(m).members)
            {
                std::unique_ptr<ParseLib::XML::Tag> tmp2(new ParseLib::XML::Tag());
                tmp2->name="item";

                recursiveTreeExport(*i,tmp2.get());

                tmp->children.emplace_back(std::move(tmp2));
            }
        }
    }
protected:
    virtual void extractSymbols(const std::vector<NULLSCR::TokenEntity>& tokens,ARCDOC::Namespace& ns) const override
    {
        extractor(tokens,ns);
    }
    virtual void initTokenizer() override
    {
        tokenizerSetup(tokenizer);
    }
public:

    virtual std::vector<std::string> getItemList() override
    {
        return std::move(std::vector<std::string>({
            "member_tree",
            "namespaces",
            "classes",
            "functions"
        }));
    }
    virtual std::shared_ptr<ParseLib::XML::Tag> getItem(const std::string& name,const ARCDOC::Namespace& ns) override
    {
        std::shared_ptr<ParseLib::XML::Tag> ret(new ParseLib::XML::Tag());
        ParseLib::XML::Tag* tag = ret.get();
        tag->name = "container";
        if (name == "member_tree")
        {
            recursiveTreeExport(ns,tag);
        }
        else if (name == "namespaces")
        {
            //
        }
        else if (name == "classes")
        {
            //
        }
        else if (name == "functions")
        {
            //
        }
        return std::move(ret);
    }
    virtual bool performAction(ARCDOC::Member& target, const std::string& action,ARCDOC::Namespace& ns)
    {
        return false;
    }
    virtual std::vector<std::string> availableActions() const
    {
        return std::move(std::vector<std::string>());
    }
};

extern "C" __declspec(dllexport) __cdecl ARCDOC::Module* moduleFactory()
{
    return new CppModule();
}

extern "C" __declspec(dllexport) __cdecl void moduleDeleter(ARCDOC::Module* m)
{
    delete m;
}
